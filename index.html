<html>
<head>
	<title>Dual - Level 1</title>
<style>
	body { background-color: #CCCCCC; }
</style>
<script src="bin/phaser.js"></script>
</head>
<body>
<h1>Dual - Level 1</h1>
<script>

var game = new Phaser.Game(1088, 576, Phaser.CANVAS, 'Level1', { preload: preload, create: create, update: update, render: render });

var nPlayers = 2;
var nTrapTypes = 2;

var playerImageKeys = [];
var playerProjImageKeys = [];
var playerFlagImageKeys = [];
var trapImageKeys = [];

function preload()
{
	game.load.image('background', 'resources/desert_BG_Scale1088_576.png');
 	game.load.tilemap('platform', 'resources/desertTilesMapSmaller.json', null, Phaser.Tilemap.TILED_JSON);
  	game.load.image('tiles','resources/desert_spritesheetSmaller2.png');

  	game.load.image('capArea', 'resources/caparea/caparea.png');

  	// Load player resources
  	for(var i = 0; i < nPlayers; ++i)
  	{
  		playerImageKeys.push('player' + (i+1));
	   	game.load.spritesheet(playerImageKeys[i], 'resources/players/player' + (i+1) + 'Spritesheet.png',32,32);

	   	playerProjImageKeys.push('p' + (i+1) + 'Proj');
	  	game.load.spritesheet(playerProjImageKeys[i], 'resources/players/misc/player' + (i+1) + 'Projectile1.png', 16, 8);

	  	playerFlagImageKeys.push('p' + (i+1) + 'flag');
	  	game.load.image(playerFlagImageKeys[i], 'resources/flags/p' + (i+1) + 'flag.png');
  	}

  	for (var i = 0; i < nTrapTypes; i++)
  	{
  		trapImageKeys.push('trap' + (i+1));
  		game.load.image(trapImageKeys[i], 'resources/traps/trap' + (i+1) + '.png');
  	}
}

var map;
var layer;
var collisionLayer;

var nFramesPerAttack; // (set automatically) number of frames in each player's attack cycle.
var nFramesPerWalkCycle; // (set automatically) number of frames in each player's walk cycle.

// Adjust this based on how fast you want the walk animation in game. 
// Note: This coefficient is used with the nFramesPerWalkCycle and the player's walk speed at any given moment to throttle the walk animation speed. However, things go wrong if the frame rate of the animation dips below 1FPS. Hence, if the calculated FPS drops below 1, it will be set to 1 when animating, which may essentially ignore this value.
var walkAnimSpeedCoeff = 30;


var captureGoal = 5;
var gameOver = false;

var players = [];
var playersStartPos = [[32,0], [1056,0]];
var playersStartFacingLeft = [false, true];
var playerAttackYOffset = 12; // The y offset from the player's position that his projectile will spawn at.

var hpBars = [];
var hpBarsFillColors = ['#1000ff','#f90010'];
var hpBarsRespawnFillColors = ['#444444','#444444'];
var hpBarsBgColors = ['#ababab','#ababab'];
var hpBarLen = 48; // Length of hp bar in pixels
var hpBarHeight = 6; // Height of hp bar in pixels

var flags = [];
var flagsStartPos = [[48,0], [1040,0]]; //[1040,70]
var flagAutoResetTime = 20000; // In milliseconds
var flagCarryOffset = [0,8];

var flagResetBars = [];
var flagResetFillColors = ['#444444','#444444'];
var flagResetBgColors = ['#ababab','#ababab'];
var flagResetBarLen = 48; // Length of hp bar in pixels
var flagResetBarHeight = 6; // Height of hp bar in pixels

var flagCapAreas = []; // Flag capture areas
var flagCapAreasPosScale = [[0,0,80,35], [1008,0,80,35]]; // [x position, y position, x scale, y scale]

var traps = [];
var nTrapAmts = [[2, 2], [2, 2]];
var trapEffects = [StunTrapEffect, SpikeTrapEffect];
var normalTrapTypeCooldowns = [2500, 2000]; // In milliseconds
var normalTrapTypeLifetimes = [10000, 10000];
var trapResetWarningDurations = [2000, 2000];
var trapFlickerInterval = 300; // In milliseconds
var trapFlickerTints = [0xffffff, 0x000000]; // [Normal tint color, flicker tint color]
var disabledTrapOpacity = 0.3;



var lMoveKeys = [];
var rMoveKeys = [];
var jumpKeys = [];
var attackKeys = [];
var useFlagKeys = [];
var placeTrap1Keys = [];
var placeTrap2Keys = [];

var spawnPoints = [];

var playerProjPools = [];
var projPoolSize = 40;

var startingHealth = 100;
var normalWalkSpeed = 150; //110 or 150

/* 
Determines the percentage of the player's walk speed that he should travel at when attacking.
So, 0.6 means that players will always at 60% of their walk speeds when attacking.
Setting this to 1 will make it have no effect. 
Setting this to 0 will make the player stationary when attacking.
Setting this to a negative value will be interesting, and will be at your own risk.
*/ 
var attackingWalkSpeedPerc = 0.6;
var carryFlagWalkSpeedPerc = 0.65;

var normalJumpPower = 400;
var normalJumpCooldown = 400; // In milliseconds
var normalAttacksPerSec = 2;
var normalWeapDmg = 25; // adjust
var normalPlayerRespawnTime = 3000; // In milliseconds

var normalProjSpeed = 350; // adjust

//TODO: remove
var testPowerupKey;

function SpikeTrapEffect(player)
{
	// Debug('player ' + player.id + ' spiked, I suppose');
	player.health -= 20;
}

function StunTrapEffect(player)
{
	// Debug('player ' + player.id + ' stunned');
	player.stunnedUntil = game.time.now + 1500;
}

/**** REGION: CREATE ****/
function create()
{
	game.physics.startSystem(Phaser.Physics.ARCADE);

	// Create GameWorld elements
	CreateGameWorld();

	CreateFlagCaptureAreas();

	// Create Flags
	// Flags first so that they will be on the back-most layer.
	CreateFlags();

	CreateTraps();

	// Put this anywhere in create AFTER CreateFlags(), depending on what you want the rendering order to be
	CreateFlagResetBars();

	// Create Players, and related bits
	CreatePlayers(); // Must be before the other player-related stuff
	CreateControls();
	CreateHealthBars();
	CreateProjectiles();
}

function CreateGameWorld()
{
	game.stage.backgroundColor = '#787878';
	game.add.sprite(0,0 ,'background');

	map = game.add.tilemap('platform');
	map.addTilesetImage('desert_spritesheetSmaller2', 'tiles');
	layer = map.createLayer('Ground');
	
	collisionLayer = map.createLayer('Collision');
	map.setCollision(1,true, 'Collision');
	collisionLayer.visible = false;

	layer.resizeWorld();
	collisionLayer.resizeWorld();
}

function CreateFlagCaptureAreas()
{
	for (var i = 0; i < nPlayers; i++)
	{
		CreateFlagCaptureArea(i);
	}
}

function CreateFlagCaptureArea(i)
{
	flagCapAreas.push(game.add.sprite(
		flagCapAreasPosScale[i][0],
		flagCapAreasPosScale[i][1],
		'capArea'));

	flagCapAreas[i].scale.set(
		flagCapAreasPosScale[i][2], 
		flagCapAreasPosScale[i][3]);

	this.game.physics.arcade.enable(flagCapAreas[i]);
	flagCapAreas[i].visible = false;
	flagCapAreas[i].id = i;
}

function CreateFlags()
{
	for(var i = 0; i < nPlayers; ++i)
	{
		CreateFlag(i);
	}
}

function CreateFlag(i)
{
	flags.push(game.add.sprite(flagsStartPos[i][0], flagsStartPos[i][1], playerFlagImageKeys[i]));
	flags[i].anchor.set(0);

	// TODO: remove
	flags[i].scale.set(0.5, 0.5);

	game.physics.arcade.enable(flags[i]);
	flags[i].body.gravity.y =400;
	flags[i].body.bounce.y = 0.2;
	
	flags[i].body.collideWorldBounds = true;
	flags[i].id = i;
	flags[i].carriedBy = -1;
	flags[i].nextAutoResetAt = -1;
}

// Creates one group of traps per player
function CreateTraps()
{
	for (var i = 0; i < nPlayers; i++)
	{
		traps.push([]);
		for (var j = 0; j < nTrapTypes; j++)
		{
			 traps[i].push([]);
			 traps[i][j] = CreateTrapGroup(i, j);
		}
	}
}

// Creates one group of traps
function CreateTrapGroup(i, j)
{
	var trapGroup = this.game.add.group();

	trapGroup.enableBody = true;
	trapGroup.physicsBodyType = Phaser.Physics.arcade;

	trapGroup.createMultiple(nTrapAmts[i][j], trapImageKeys[j]);


	trapGroup.setAll('anchor.x', 0);
	trapGroup.setAll('anchor.y', 1);
	trapGroup.setAll('checkWorldBounds', true);

	// Creating new members for elements of a group CANNOT be done through setAll()
	trapGroup.forEach(function(trap)
	{
		trap.typeID = j;
		trap.effect = trapEffects[j];
		trap.coolDown = normalTrapTypeCooldowns[j];
		trap.lifetime = normalTrapTypeLifetimes[j];

		trap.nextTriggerAt = -1;
		trap.ready = false;
		trap.resetAt = -1;
		trap.nextFlickerAt = -1;
	});

	return trapGroup;
}

function CreateFlagResetBars()
{
	for (var i = 0; i < nPlayers; i++)
	{
		CreateFlagResetBar(i);
	}
}

function CreateFlagResetBar(i)
{
	// Create health bar background
    var bmd = this.game.add.bitmapData(flagResetBarLen, flagResetBarHeight);
    bmd.ctx.beginPath();
    bmd.ctx.rect(0, 0, flagResetBarLen, flagResetBarHeight);
    bmd.ctx.fillStyle = flagResetBgColors[i];
    bmd.ctx.fill();
    
    var flagResetBar = this.game.add.sprite(
    	flags[i].body.position.x - flagResetBarLen / 2, 
    	flags[i].body.position.y - flagResetBarHeight,
    	bmd);
    flagResetBar.anchor.set(0, 0.5);

    // Create reset fill
    bmd = this.game.add.bitmapData(flagResetBarLen,flagResetBarHeight);
    bmd.ctx.beginPath();
    bmd.ctx.rect(0, 0, flagResetBarLen, flagResetBarHeight);
    bmd.ctx.fillStyle = flagResetFillColors[i];
    bmd.ctx.fill();

    var flagResetFill = this.game.add.sprite(
    	flagResetBar.position.x,
    	flagResetBar.position.y,
    	bmd);
    flagResetFill.anchor.set (0, 0.5);
    flagResetFill.cropEnabled = true;

    flagResetFill.rectCrop = new Phaser.Rectangle(0, 0, bmd.width, bmd.height);
    flagResetFill.crop(flagResetFill.rectCrop);
    flagResetFill.rectCrop.width = 0; // Start invisible
    flagResetFill.updateCrop();

    // Set flagResetFill as a member of flagResetBar because they are linked.
    flagResetBar.fill = flagResetFill;

    flagResetBar.visible = true;

    flagResetBars.push(flagResetBar);
}

function CreatePlayers()
{
	for(var i = 0; i < nPlayers; ++i)
	{
		players.push(game.add.sprite(playersStartPos[i][0], playersStartPos[i][1], playerImageKeys[i]));
		players[i].facingLeft = playersStartFacingLeft[i];
		ConfigurePlayer(players[i]);
		players[i].id = i;
	}
}

function ConfigurePlayer(player)
{
	game.physics.arcade.enable(player);
	
	player.anchor.set(0.5, 0.5);

	player.body.bounce.y = 0.2;
	player.body.gravity.y =1500;
	player.body.collideWorldBounds = true;
	player.body.width = 14;
	player.body.height = 28;

	player.health = startingHealth;
	player.alive = true;
	player.stunnedUntil = -1;
	player.walkSpeed = normalWalkSpeed;
	player.jumpPower = normalJumpPower;
	player.nextJumpAt = 0;
	player.attacksPerSec = normalAttacksPerSec;
	player.nextAttackAt = 0;
	player.projSpeed = normalProjSpeed;
	player.weapDmg = normalWeapDmg;
	player.respawnTime = normalPlayerRespawnTime;
	player.nextRespawnAt = 0;
	player.carryingFlag = -1;
	player.score = 0;

	player.animations.add('left',[33,34,35],10,true);
	player.animations.add('right',[30,31,32],10,true);
	player.animations.add('idleLeft',[9,10,11],5,true);
	player.animations.add('idleRight',[6,7,8],5,true);

	player.animations.add('dieFallRight',[23,22,21,20,19,18],12,false);
	player.animations.add('dieFallLeft',[12,13,14,15,16,17],12,false);
	player.animations.add('attackLeft',[5,4,3],nFramesPerAttack*normalAttacksPerSec,true);
	player.animations.add('attackRight',[0,1,2],nFramesPerAttack*normalAttacksPerSec,true);

	player.animations.add('stunnedFaceLeft',[27,28,29],5,false);
	player.animations.add('stunnedFaceRight',[24,25,26],5,false);

	nFramesPerAttack = player.animations.getAnimation('attackLeft').frameTotal;
	nFramesPerWalkCycle = player.animations.getAnimation('left').frameTotal
}

function CreateControls()
{
	// Player 1
	lMoveKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.A));
	rMoveKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.D));
	jumpKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.W));
	attackKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR));
	useFlagKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.S));
	useFlagKeys[0].onDown.add(function(){UseFlag(players[0]);}, this);
	placeTrap1Keys.push(game.input.keyboard.addKey(Phaser.Keyboard.T));
	placeTrap1Keys[0].onDown.add(function(){PlaceTrap(players[0], 0);}, this);
	placeTrap2Keys.push(game.input.keyboard.addKey(Phaser.Keyboard.Y));
	placeTrap2Keys[0].onDown.add(function(){PlaceTrap(players[0], 1);}, this);

	// Player 2
	lMoveKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.LEFT));
	rMoveKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.RIGHT));
	jumpKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.UP));
	attackKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_7));
	useFlagKeys.push(game.input.keyboard.addKey(Phaser.Keyboard.DOWN));
	useFlagKeys[1].onDown.add(function(){UseFlag(players[1]);}, this);
	placeTrap1Keys.push(game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_8));
	placeTrap1Keys[1].onDown.add(function(){PlaceTrap(players[1], 0);}, this);
	placeTrap2Keys.push(game.input.keyboard.addKey(Phaser.Keyboard.NUMPAD_9));
	placeTrap2Keys[1].onDown.add(function(){PlaceTrap(players[1], 1);}, this);

	//TODO: remove
	testPowerupKey = this.game.input.keyboard.addKey(Phaser.Keyboard.P);
	testPowerupKey.onDown.add(function(){ActivatePowerup();}, this);
}

function CreateHealthBars()
{
	for(var i = 0; i < nPlayers; ++i)
	{
		CreateHealthBar(i);
	}
}

function CreateHealthBar(i)
{
	// Create health bar background
    var bmd = this.game.add.bitmapData(hpBarLen, hpBarHeight);
    bmd.ctx.beginPath();
    bmd.ctx.rect(0, 0, hpBarLen, hpBarHeight);
    bmd.ctx.fillStyle = hpBarsBgColors[i];
    bmd.ctx.fill();
    
    var hpBar = this.game.add.sprite(
    	players[i].body.position.x - hpBarLen / 2, 
    	players[i].body.position.y - hpBarHeight,
    	bmd);
    hpBar.anchor.set(0, 0.5);
    
    // Create health bar fill
    bmd = this.game.add.bitmapData(hpBarLen, hpBarHeight);
    bmd.ctx.beginPath();
    bmd.ctx.rect(0, 0, hpBarLen, hpBarHeight);
    bmd.ctx.fillStyle = hpBarsFillColors[i];
    bmd.ctx.fill();

    var hpFill = this.game.add.sprite(
    	hpBar.position.x,
    	hpBar.position.y,
    	bmd);
    hpFill.anchor.set (0, 0.5);
    hpFill.cropEnabled = true;
    // Set up the fill cropping mechanism.
    hpFill.rectCrop = new Phaser.Rectangle(0, 0, bmd.width, bmd.height);
    hpFill.crop(hpFill.rectCrop);

    // Create respawn fill
    bmd = this.game.add.bitmapData(hpBarLen, hpBarHeight);
    bmd.ctx.beginPath();
    bmd.ctx.rect(0, 0, hpBarLen, hpBarHeight);
    bmd.ctx.fillStyle = hpBarsRespawnFillColors[i];
    bmd.ctx.fill();

    var hpRespawnFill = this.game.add.sprite(
    	hpBar.position.x,
    	hpBar.position.y,
    	bmd);
    hpRespawnFill.anchor.set (0, 0.5);
    hpRespawnFill.cropEnabled = true;

    hpRespawnFill.rectCrop = new Phaser.Rectangle(0, 0, bmd.width, bmd.height);
    hpRespawnFill.crop(hpRespawnFill.rectCrop);
    hpRespawnFill.rectCrop.width = 0; // Start invisible
    hpRespawnFill.updateCrop();

    // Set hpFill as a member of hpBar because they are linked.
    hpBar.fill = hpFill;
    hpBar.respawnFill = hpRespawnFill;

    hpBars.push(hpBar);
}

function CreateProjectiles()
{
	for(var i = 0; i < nPlayers; ++i)
	{
		CreateProjectilePool(i);
	}
}

function CreateProjectilePool(i)
{
	// Add an empty sprite group into our game
	playerProjPools.push(this.game.add.group());

	// Enable physics to the whole sprite group
	playerProjPools[i].enableBody = true;
	playerProjPools[i].physicsBodyType = Phaser.Physics.arcade;

	// Add 100 'projectile' sprites in the group.
	// By default this uses the first frame of the spritesheet and
	// sets the initial state as non-existing (i.e. killed / dead)
	playerProjPools[i].createMultiple(projPoolSize, playerProjImageKeys[i]);

	// Sets the anchors of all sprites
	playerProjPools[i].setAll('anchor.x', 0.5);
	playerProjPools[i].setAll('anchor.y', 0.5);

	// Misc settings
	playerProjPools[i].setAll('outOfBoundsKill', true);
	playerProjPools[i].setAll('checkWorldBounds', true);

	playerProjPools[i].forEach(function (projectile)
	{
		projectile.damage = 0;
		projectile.id = i;
		projectile.animations.add('projAnim', null, 6, true);
	});
}
/**** ENDREGION: CREATE ****/


/**** REGION: UPDATE ****/
function update()
{
	for (var i = 0; i < nPlayers; i++)
	{
		HandlePlayerPhysics(i);
		HandlePlayerInput(i);
		HandleFlagPhysics(i);

		if(players[i].alive && players[i].health <= 0)
		{
			KillPlayer(i);
			StartRespawnTimer(i);
		}

		if(!players[i].alive && game.time.now >= players[i].nextRespawnAt)
		{
			RevivePlayer(i);
		}
	}

	HandleProjPhysics();

	if(!gameOver)
	{
		CheckGameCollisions();
		CheckFlagAutoReset();
		CheckTrapTimers();
	}

	// TODO: extract

}

function HandlePlayerInput(i)
{
	if(!players[i].alive) return;
	if(HandlePlayerStun(i))
	{
		StunnedAnim(players[i]);
		return;
	}

	if(gameOver) 
	{
		IdleAnim(players[i]);
		return;
	}

	// Attack logic and check if attack encumbrance effects should be applied
	var attacking = false;
	if(attackKeys[i].isDown)
	{
		attacking = true;
		AttackLogic(players[i])
	}

	// Check if flag encumbrance effects should be applied
	var hasFlag = players[i].carryingFlag != -1;

	if (lMoveKeys[i].isDown)
	{
		players[i].facingLeft = true;
		WalkLeftLogic(players[i],
			(attacking ? attackingWalkSpeedPerc : 1) *
			(hasFlag ? carryFlagWalkSpeedPerc : 1)
			);
	}
	else if(rMoveKeys[i].isDown)
	{
		players[i].facingLeft = false;
		WalkRightLogic(players[i],
			(attacking ? attackingWalkSpeedPerc : 1) *
			(hasFlag ? carryFlagWalkSpeedPerc : 1)
			);
	}

	if (jumpKeys[i].isDown && players[i].body.onFloor())
	{
	    JumpLogic(players[i]);
	}

	if (attacking)
	{
		AttackAnim(players[i]);
	}
	else if (lMoveKeys[i].isDown || rMoveKeys[i].isDown)
	{
		WalkAnim(players[i]);
	}
	else
	{
		IdleAnim(players[i]);
	}
}

function HandlePlayerStun(i)
{
	// Not stunned
	if(players[i].stunnedUntil == -1) 
		{return false;}
	else
	{
		if(players[i].stunnedUntil <= game.time.now)
		{
			// Stun worn off
			players[i].stunnedUntil = -1;
			return false;
		}
		else
		{
			// Stil stunned
			return true;
		}
	}
}

function HandlePlayerPhysics(i)
{
	players[i].body.velocity.x = 0;
	game.physics.arcade.collide(players[i], collisionLayer);
}

function HandleFlagPhysics(i)
{
	// Normally collide with the world and be subject to gravity if not carried.
	if(flags[i].carriedBy == -1) 
	{
		flags[i].body.gravity.y =400;
		game.physics.arcade.collide(flags[i], collisionLayer);
		return;
	}

	// Follow player if carried
	flags[i].body.gravity.y = 0;
	var cb = flags[i].carriedBy;
	flags[i].body.position.set(
		players[cb].body.position.x + flagCarryOffset[0], 
		players[cb].body.position.y - players[cb].height + flagCarryOffset[1]);
}

function CheckGameCollisions()
{
	CheckPlayerCollisions();
	CheckFlagCollisions();
	CheckTrapCollisions();
}

function HandleProjPhysics()
{
	for(var i = 0; i < playerProjPools.length; ++i)
	{
		// Projectiles hit terrain
		this.game.physics.arcade.overlap(
			playerProjPools[i], collisionLayer, this.ProjHitEnv, null, this);
	}
}

function CheckPlayerCollisions()
{
	// Projectiles collision
	for(var i = 0; i < nPlayers; ++i)
	{
		if(!players[i].alive) {continue;}

		for(var j = 0; j < playerProjPools.length; ++j)
		{
			// If these are the not player's own projectiles
			// And the target player is alive
			if(i != j)
			{
				this.game.physics.arcade.overlap(
					playerProjPools[j], players[i], this.ProjHitPlayer, null, this);
			}
		}
	}
}

function CheckFlagCollisions()
{
	for (var i = 0; i < flags.length; i++) 
	{
		for (var j = 0; j < flagCapAreas.length; j++) 
		{
			if(i == j)
			{
				// Flag not carried, not already on timer, and not in its own base
				if(flags[i].carriedBy == -1 && 
					flags[i].nextAutoResetAt == -1 &&
					!this.game.physics.arcade.overlap(flags[i], flagCapAreas[j]))
				{
 					flags[i].nextAutoResetAt = game.time.now + flagAutoResetTime;
				}
			}
			else if(this.game.physics.arcade.overlap(flags[i], flagCapAreas[j]))
			{
				FlagCaptured(flags[i], flagCapAreas[j]);
			}
		}
	}
}

function CheckTrapCollisions()
{
	for (var i = 0; i < traps.length; i++)
	{
		for (var j = 0; j < traps[i].length; j++)
		{
			this.game.physics.arcade.overlap(
				traps[i][j], players, this.PlayerTriggeredTrap, null, this);
		}
	}
}

function PlayerTriggeredTrap(player, trap)
{
	// Debug('trap with id ' + trap.typeID + ' not triggered');
	if(trap.ready && player.alive)
	{
		// Debug('trap with id ' + trap.typeID + ' triggered');
		trap.effect(player);
		trap.ready = false;
		trap.alpha = disabledTrapOpacity;
		trap.nextTriggerAt = game.time.now + trap.coolDown;
	}
}

function PlaceTrap(player, trapTypeIndex)
{
	if(player.body.onFloor())
	{		
		// Debug('trap placed by ' + player.id);

		var trap = traps[player.id][trapTypeIndex].getFirstExists(false);
		trap.reset(
			player.body.position.x - player.body.width / 2,
			player.body.position.y + player.body.height
			);
		trap.ready = false;
		trap.alpha = disabledTrapOpacity;
		trap.tint = trapFlickerTints[0];
		trap.nextFlickerAt = -1;
		trap.nextTriggerAt = game.time.now + trap.coolDown;
		trap.resetAt = game.time.now + trap.lifetime;
	}
}

function CheckTrapTimers()
{
	for (var i = 0; i < traps.length; i++) {
		for (var j = 0; j < traps[i].length; j++) {
			for (var k = 0; k < traps[i][j].length; k++) {
				var trap = traps[i][j].getAt(k);

				if(trap.resetAt != -1)
				{
					var trapTTL = trap.resetAt - game.time.now;
					if(trapTTL <= 0)
					{
						ResetTrap(trap);
					}
					else if(trapTTL <= trapResetWarningDurations[j] &&
						trap.nextFlickerAt <= game.time.now)
					{
						ToggleTrapTint(trap);
						trap.nextFlickerAt = game.time.now + trapFlickerInterval;
					}
				}

				if(!trap.ready &&
					trap.nextTriggerAt != -1 &&
				 	trap.nextTriggerAt <= game.time.now)
				{
					PrimeTrap(trap);
				}

				// trap.alpha = ((trap.resetAt - game.time.now) / trap.lifetime);
			};
		};
	};
}

function ToggleTrapTint(trap)
{
	trap.tint = trap.tint == trapFlickerTints[0] ? trapFlickerTints[1] : trapFlickerTints[0];
}

function ResetTrap(trap)
{
	// Debug('trap reset');
	trap.nextTriggerAt = -1;
	trap.resetAt = -1;
	trap.ready = false;
	trap.nextFlickerAt = -1;
	trap.alpha = 1;
	trap.tint = trapFlickerTints[0];
	trap.kill();
}

function PrimeTrap(trap)
{
	// Debug('trap primed');
	trap.ready = true;
	trap.alpha = 1;
	// TODO: add sound
}

function CheckFlagAutoReset()
{
	for (var i = 0; i < flags.length; i++) 
	{
		if(flags[i].nextAutoResetAt != -1)
		{
			if(flags[i].carriedBy != -1)
			{
				// If flag has been picked up, reset the auto-reset timer
				flags[i].nextAutoResetAt = -1;
			}
			else if(flags[i].nextAutoResetAt <= game.time.now)
			{
				ResetFlag(flags[i]);
			}
		}
	}
}

function ProjHitPlayer(player, proj)
{
	player.health -= proj.damage;
	proj.kill();
}

function ProjHitEnv(proj, env)
{
	proj.kill();
}

function UseFlag(player)
{
	if(!player.alive || player.stunnedUntil != -1) 
		{return;}

	// Debug('using flag');
	if(player.carryingFlag != -1)
	{
		// Debug(player.id + ' dropping ' + flags[player.carryingFlag].id);
		DropFlag(player);
		return;
	}

	for(var i = 0; i < flags.length; ++i)
	{
		if(this.game.physics.arcade.overlap(player, flags[i]))
		{
			// Debug('overlap flag');
			if(player.carryingFlag == -1)
			{
				// Debug(player.id + ' picking up ' + flags[i].id);
				PickupFlag(player, flags[i]);
			}
		}
	}
}

function PickupFlag(player, flag)
{
	// Debug('pick0: ' + players[0].carryingFlag);
	// Debug('pick1: ' + players[1].carryingFlag);
	// Debug('flag0: ' + flags[0].carriedBy);
	// Debug('flag1: ' + flags[1].carriedBy);

	if(player.carryingFlag != -1)
	{
		Debug("player " + player.id + " already carrying flag " + flag.id);
	}

	if(flag.carriedBy != -1)
	{
		Debug("flag " + flag.id + " already carried by player " + player.id);
	}

	flag.carriedBy = player.id;
	flag.nextAutoResetAt = -1;
	player.carryingFlag = flag.id;

	// Debug('pick0: ' + players[0].carryingFlag);
	// Debug('pick1: ' + players[1].carryingFlag);
	// Debug('flag0: ' + flags[0].carriedBy);
	// Debug('flag1: ' + flags[1].carriedBy);
}

function DropFlag(player)
{
	// Debug('drop0: ' + players[0].carryingFlag);
	// Debug('drop1: ' + players[1].carryingFlag);
	// Debug('flag0: ' + flags[0].carriedBy);
	// Debug('flag1: ' + flags[1].carriedBy);

	// Check is here because player is told to drop flag upon death, and he may not be carrying a flag.
	if(player.carryingFlag == -1)
	{
		return;
	}

	// Debug('Drop flag 2');

	// Teleport it to the player before dropping it so the player can't do anything funny with the flag.
	flags[player.carryingFlag].position.set(
		player.body.position.x + player.body.width / 2, 
		player.body.position.y + player.body.height / 2);

	flags[player.carryingFlag].carriedBy = -1;
	player.carryingFlag = -1;

	// Debug('drop0: ' + players[0].carryingFlag);
	// Debug('drop1: ' + players[1].carryingFlag);
	// Debug('flag0: ' + flags[0].carriedBy);
	// Debug('flag1: ' + flags[1].carriedBy);
}

function KillPlayer(i)
{
	players[i].alive = false;
	players[i].stunnedUntil = -1;

	DropFlag(players[i]);

	players[i].animations.play(
		players[i].facingLeft?
		'dieFallLeft' :
		'dieFallRight'
		);

	// TODO: remove
	// this.game.add.text(0, 0,
 //    'player '+i+' is dead.Health: ' + players[i].health,
 //    {font: '20px monospace', fill: '#000', align: 'center'}
 //    );

	// TODO: Add sound
}

function StartRespawnTimer(i)
{
	players[i].nextRespawnAt = game.time.now + players[i].respawnTime;
}

function RevivePlayer(i)
{
	// Teleport to start
	/*
	Important to teleport to start first before marking as alive so that projectiles still flying over the player's corpse will not hurt him.
	*/
	players[i].position.set(playersStartPos[i][0], playersStartPos[i][1]);

	players[i].health = startingHealth;
	players[i].alive = true;

	// TODO: add sound
}

function FlagCaptured(flag, capArea)
{
	Debug('cap0: ' + players[0].carryingFlag);
	Debug('cap1: ' + players[1].carryingFlag);
	Debug('flag0: ' + flags[0].carriedBy);
	Debug('flag1: ' + flags[1].carriedBy);

	players[flag.carriedBy].carryingFlag = -1;
	ResetFlag(flag);

	players[capArea.id].score++;

	// Debug('0: ' + players[0].score);
	// Debug('1: ' + players[1].score);

	Debug('cap0: ' + players[0].carryingFlag);
	Debug('cap1: ' + players[1].carryingFlag);
	Debug('flag0: ' + flags[0].carriedBy);
	Debug('flag1: ' + flags[1].carriedBy);

	CheckForWin(players[capArea.id]);
}

function ResetFlag(flag)
{
	flag.body.position.set(
		flagsStartPos[flag.id][0],
		flagsStartPos[flag.id][1]
		);
	flag.carriedBy = -1;
	// TODO: remove
	
	flag.nextAutoResetAt = -1;
	Debug(flag.body.position);
}

function CheckForWin(player)
{
	if(player.score >= captureGoal)
	{
		EndGame(player);
	}
}

function EndGame(winnerPlayer)
{
	gameOver = true;
	for (var i = 0; i < useFlagKeys.length; i++)
	{
		useFlagKeys[i].onDown.removeAll(this);
	};

	// TODO: remove
	Debug('Player ' + (winnerPlayer.id + 1) + ' has won!');

	// TODO: more stuff
}

function JumpLogic(player, optMultiplier)
{
	if(player.nextJumpAt <= game.time.now)
	{
		if(optMultiplier == null) optMultiplier = 1;
		player.body.velocity.y = -(player.jumpPower * optMultiplier);
		player.nextJumpAt = game.time.now + normalJumpCooldown;
	}
}

function WalkLeftLogic(player, optMultiplier)
{
	// Reduction parameter is optional
	if(optMultiplier == null) optMultiplier = 1;
	player.body.velocity.x = -(player.walkSpeed * optMultiplier);
}

function WalkRightLogic(player, optMultiplier)
{
	if(optMultiplier == null) optMultiplier = 1;
	player.body.velocity.x = (player.walkSpeed * optMultiplier);
}

function AttackLogic(player)
{
	// Get a projectile
	if(game.time.now > player.nextAttackAt && playerProjPools[player.id].countDead() > 0)
	{
		var proj = playerProjPools[player.id].getFirstExists(false);
		proj.reset(
			player.body.position.x + (player.facingLeft ? -player.width/2 : player.width), 
			player.body.position.y + playerAttackYOffset);
		proj.play('projAnim');
		//TODO: play projectile sound

		// Give it a damage
		proj.damage = player.weapDmg;

		// Fire it in the correct direction
		proj.body.velocity.x = player.facingLeft ? -player.projSpeed : player.projSpeed;

		// Set cooldown
		player.nextAttackAt = game.time.now + 1000 / player.attacksPerSec;
	}
}
function AttackAnim(player)
{
	var animSpeed = player.attacksPerSec * nFramesPerAttack;

	// Prevent animSpeed from going below 1FPS (causes problems)
	if(animSpeed < 1) {animSpeed = 1;}

	if (player.facingLeft)
	{
		player.animations.getAnimation('attackLeft').speed = animSpeed;
		player.animations.play('attackLeft');
	}
	else
	{
		player.animations.getAnimation('attackRight').speed = animSpeed;
		player.animations.play('attackRight');
	}
}
function IdleAnim(player)
{
	if (player.facingLeft)
		player.animations.play('idleLeft');
	else
		player.animations.play('idleRight');
}
function WalkAnim(player)
{
	var animSpeed = nFramesPerWalkCycle * (player.walkSpeed / 1000) * walkAnimSpeedCoeff;

	// Prevent animSpeed from going below 1FPS (causes problems)
	if(animSpeed < 1) {animSpeed = 1;}

	if(player.facingLeft)
	{
		player.animations.getAnimation('left').speed = animSpeed;
		player.animations.play('left');
	}
	else
	{
		player.animations.getAnimation('right').speed = animSpeed;
		player.animations.play('right');
	}
}
function StunnedAnim(player)
{
	if(player.facingLeft)
		player.animations.play('stunnedFaceLeft');
	else
		player.animations.play('stunnedFaceRight');
}
/**** ENDREGION: UPDATE ****/

function render() 
{

	// this.game.debug.body(players[0]);
	// this.game.debug.body(players[1]);

	for (var i = 0; i < flags.length; i++) {
		this.game.debug.body(flags[i]);
	}

	RenderHealthBars();
	if(!gameOver) {RenderFlagResetBars();}

}

function RenderFlagResetBars()
{
	for (var i = 0; i < flagResetBars.length; i++) 
	{
			// Update bar position
		flagResetBars[i].position.set(
			flags[i].body.position.x - flagResetBars[i].width / 2 + flags[i].body.width / 2, // 4 because hpBar's anchor was changed after it was created.
			flags[i].body.position.y - flagResetBars[i].height);
		flagResetBars[i].fill.position = flagResetBars[i].position;

		if(flags[i].nextAutoResetAt == -1)
		{
			// Make invisible
			flagResetBars[i].visible = false;
			// Update the bar fill amount.
		    flagResetBars[i].fill.rectCrop.width = 0;
		}
		else
		{
			// Make visible
			flagResetBars[i].visible = true;
			// Update the bar fill amount.
		    flagResetBars[i].fill.rectCrop.width = flagResetBars[i].width - (((flags[i].nextAutoResetAt - game.time.now)/flagAutoResetTime) * flagResetBars[i].width);
		}

		flagResetBars[i].fill.updateCrop();
	}
}

function RenderHealthBars()
{
	for (var i = 0; i < nPlayers; i++) 
	{
			// Update health bar position
		hpBars[i].position.set(
			players[i].body.position.x - hpBars[i].width / 2 + players[i].body.width / 2, // 4 because hpBar's anchor was changed after it was created.
			players[i].body.position.y - hpBars[i].height);
		hpBars[i].fill.position = hpBars[i].position;
		hpBars[i].respawnFill.position = hpBars[i].position;

		if(players[i].alive)
		{
			// Update the health bar fill amount.
		    hpBars[i].fill.rectCrop.width = players[i].health / startingHealth * hpBars[i].width;
		    // Respawn should be invisible
		    hpBars[i].respawnFill.rectCrop.width = 0;
		}
		else
		{
			// Update the respawn bar fill amount.
		    hpBars[i].respawnFill.rectCrop.width = hpBars[i].width - (((players[i].nextRespawnAt - game.time.now)/players[i].respawnTime) * hpBars[i].width);
		    // Health fill should be invisible
		    hpBars[i].fill.rectCrop.width = 0;
		}

		hpBars[i].fill.updateCrop();
		hpBars[i].respawnFill.updateCrop();
	}
}



//TODO: remove
function Debug(msg)
{
	if(this.debugText == null)
	{
		this.debugText = this.game.add.text(game.world.width / 2, game.world.height / 2 - 100,
	        msg,
	        {font: '20px monospace', fill: '#000', align: 'center'}
	        );
		this.debugText.anchor.set(0.5);
	}
	else
	{
		this.debugText.text += '\n' + msg;
	}
}

//TODO: remove
function ActivatePowerup()
{
	Debug(flags[0].body.position);
	Debug('0: ' + this.game.physics.arcade.overlap(flags[0], flagCapAreas[0]));
	Debug('1: ' + this.game.physics.arcade.overlap(flags[1], flagCapAreas[1]));

	players[0].walkSpeed = players[0].walkSpeed == 150 ? 300 : 150;
	players[1].walkSpeed = players[1].walkSpeed == 150 ? 300 : 150;

	// if(this.testText == null)
	// {
	// 	this.testText = this.game.add.text(game.world.width / 2, game.world.height / 2,
	//         'powerup activated: speed is ' + players[0].walkSpeed,
	//         {font: '20px monospace', fill: '#000', align: 'center'}
	//         );
	// 	this.testText.anchor.set(0.5);
	// }
	// else
	// {
	// 	this.testText.text = 'powerup activated: speed is ' + players[0].walkSpeed;
	// }
}



</script>
</body>
</html>
